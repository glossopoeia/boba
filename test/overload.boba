overload eq as Eq?
    : <= Eq? (| x... a^s4 a^s5 ===[ e1... ][ p1... ][ True ]==> x... Bool^s6 |)^False =>
      z... a^s1 a^s2 ===[ e... ][ p... ][ True ]==> z... Bool^s3

instance eq
    : z... Bool^s1 Bool^s2 ===[ e... ][ p... ][ True ]==> z... Bool^s3
    = eq-bool

instance eq
    : z... (I32 u)^s1 (I32 u)^s2 ===[ e... ][ p... ][ True ]==> z... Bool^s3
    = eq-i32

instance eq
    : <= Eq? (| x... y^s4 y^s5 ===[ e1... ][ p1... ][ True ]==> x... Bool^s6 |)^False =>
      z... [y^s7]^s1 [y^s8]^s2 ===[ e... ][ p... ][ True ]==> z... Bool^s3 
    =
    for el <= list, er <= list fold res <= True then {
        el er eq res and-bool
    }

func test-eq-1 = True False eq

func test-eq-2 = True eq

func test-eq-3 = 1 eq

func test-eq-4 w x y z = w x eq y z eq and-bool

// TODO: this is broken currently
//func eq-tuple =
//    for fold res <= true with e1 <= tuple, e2 <= tuple then {
//        e1 e2 eq res and-bool
//    }

main = { 1 test-eq-3; let x; 0 }