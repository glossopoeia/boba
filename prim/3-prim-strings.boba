import native "strings"

data String (t : Trust) (c : Clearance)

native trust-string
    : z... (String t c)^s ===[ e... ][ p... ][ true ]==> z... (String True c)^s
    =
    #

native distrust-string
    : z... (String t c)^s ===[ e... ][ p... ][ true ]==> z... (String False c)^s
    =
    #

about :
> Clone returns a fresh copy of s. It guarantees to make a copy of s
> into a new allocation, which can be important when retaining only a
> small substring of a much larger string. Using Clone can help such
> programs use less memory. Of course, since using Clone makes a copy,
> overuse of Clone can make programs use more memory. Clone should
> typically be used only rarely, and only when profiling indicates that
> it is needed. For strings of length zero the string "" will be
> returned and no allocation is made.
native clone-string
    : z... (String t c)^s1 ===[ e... ][ p... ][ true ]==> z... (String t c)^s1 (String t c)^s2
    =
    # str := fiber.PeekOneValue().(string)
    # fiber.PushValue(strings.Clone(str))

about :
> Compare returns an integer comparing two strings lexicographically.
> The result will be 0 if a == b, -1 if a < b, and +1 if a > b.
> Compare is included only for symmetry with package bytes. It is usually
> clearer and always faster to use the built-in string comparison
> operators ==, <, >, and so on.
native compare-string
    : z... (String t1 c1)^s1 (String t2 c2)^s2 ===[ e... ][ p... ][ true ]==> z... (I32 one)^s3
    =
    # strL := fiber.PopOneValue().(string)
    # strR := fiber.PopOneValue().(string)
    # fiber.PushValue(strings.Compare(strL, strR))

export { }